<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Enunciado
Na minha primeira leitura, vi que esta é uma questão clássica de segtree. Um vetor de tamanho \(10^5\) e \(10^5\) queries dentro desse intervalo. Iremos fazer uma segtree para o mínimo num intervalo e outra para o máximo, sendo a resposta da query em um intervalo o max-min. Para simplificar isso, podemos guardar as duas árvores apenas em um vetor de pairs.
Porém após implementar a primeira solução e não funcionar fiz uma segunda leitura e percebi que o max e o min não podem estar no mesmo balde (na mesma posição no vetor)."><meta itemprop=name content="Solução OBI 2018 Baldes"><meta itemprop=description content="Enunciado
Na minha primeira leitura, vi que esta é uma questão clássica de segtree. Um vetor de tamanho \(10^5\) e \(10^5\) queries dentro desse intervalo. Iremos fazer uma segtree para o mínimo num intervalo e outra para o máximo, sendo a resposta da query em um intervalo o max-min. Para simplificar isso, podemos guardar as duas árvores apenas em um vetor de pairs.
Porém após implementar a primeira solução e não funcionar fiz uma segunda leitura e percebi que o max e o min não podem estar no mesmo balde (na mesma posição no vetor)."><meta itemprop=datePublished content="2020-02-05T00:00:00+00:00"><meta itemprop=dateModified content="2020-02-05T00:00:00+00:00"><meta itemprop=wordCount content="389"><meta itemprop=keywords content="OBI,"><meta property="og:title" content="Solução OBI 2018 Baldes"><meta property="og:description" content="Enunciado
Na minha primeira leitura, vi que esta é uma questão clássica de segtree. Um vetor de tamanho \(10^5\) e \(10^5\) queries dentro desse intervalo. Iremos fazer uma segtree para o mínimo num intervalo e outra para o máximo, sendo a resposta da query em um intervalo o max-min. Para simplificar isso, podemos guardar as duas árvores apenas em um vetor de pairs.
Porém após implementar a primeira solução e não funcionar fiz uma segunda leitura e percebi que o max e o min não podem estar no mesmo balde (na mesma posição no vetor)."><meta property="og:type" content="article"><meta property="og:url" content="https://gbrls.netlify.com/obi2018-baldes/"><meta property="article:published_time" content="2020-02-05T00:00:00+00:00"><meta property="article:modified_time" content="2020-02-05T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Solução OBI 2018 Baldes"><meta name=twitter:description content="Enunciado
Na minha primeira leitura, vi que esta é uma questão clássica de segtree. Um vetor de tamanho \(10^5\) e \(10^5\) queries dentro desse intervalo. Iremos fazer uma segtree para o mínimo num intervalo e outra para o máximo, sendo a resposta da query em um intervalo o max-min. Para simplificar isso, podemos guardar as duas árvores apenas em um vetor de pairs.
Porém após implementar a primeira solução e não funcionar fiz uma segunda leitura e percebi que o max e o min não podem estar no mesmo balde (na mesma posição no vetor)."><meta name=generator content="Hugo 0.66.0"><title>Solução OBI 2018 Baldes | gbrls</title><link rel=canonical href=/obi2018-baldes/><link rel=stylesheet href=/css/base.min.1a0a1f9140a60cc15b9f4169eb54b4ec2f5c75ea37240cc1e5a67cec0188d3ae.css integrity="sha256-GgofkUCmDMFbn0Fp61S07C9cdeo3JAzB5aZ87AGI064=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css integrity=sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js integrity=sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload=renderMathInElement(document.body);></script><link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel=stylesheet></head><body><nav class=u-background><div class=u-wrapper><ul class=Banner><li class="Banner-item Banner-item--title"><a class="Banner-link u-clickable" href=/>gbrls</a></li><li class=Banner-item><a class="Banner-link u-clickable" href=/about/>About</a></li><li class=Banner-item><a class="Banner-link u-clickable" href=/posts/>Posts</a></li><li class=Banner-item><a class="Banner-link u-clickable" href=/tags/>Tags</a></li><li class=Banner-item><a class="Banner-link u-clickable" href=/categories/>Categories</a></li><li class=Banner-item><a class="Banner-link u-clickable" href=/index.xml>RSS</a></li></ul></div></nav><main><div class=u-wrapper><div class=u-padding><article><header class=Heading><h2 class=Heading-title><a class="Heading-link u-clickable" href=/obi2018-baldes/ rel=bookmark>Solução OBI 2018 Baldes</a></h2><time datetime=2020-02-05T00:00:00Z>5 February, 2020</time></header><p><a href=https://olimpiada.ic.unicamp.br/pratique/pu/2018/f3/baldes/>Enunciado</a><br>Na minha primeira leitura, vi que esta é uma questão clássica de segtree. Um vetor de tamanho \(10^5\) e \(10^5\) queries dentro desse intervalo. Iremos fazer uma segtree para o mínimo num intervalo e outra para o máximo, sendo a resposta da query em um intervalo o max-min. Para simplificar isso, podemos guardar as duas árvores apenas em um vetor de pairs.</p><p>Porém após implementar a primeira solução e não funcionar fiz uma segunda leitura e percebi que o max e o min não podem estar no mesmo balde (na mesma posição no vetor). Então troquei o pair por uma struct, para guardar de qual balde o max e o min vieram. Quando o min e o max estiverem no mesmo balde temos uma certeza, um dos dois faz parte da solução. Nesse caso podemos testar, o query sem o min, mas com o max e o query sem o max, mas com o min.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ii</span> {
    <span style=color:#66d9ef>int</span> first;
    <span style=color:#66d9ef>int</span> second;
    <span style=color:#66d9ef>int</span> i;
    <span style=color:#66d9ef>int</span> j;
} ii;
<span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;

<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> MAX <span style=color:#f92672>=</span> <span style=color:#ae81ff>5e5</span><span style=color:#f92672>+</span><span style=color:#ae81ff>50</span>;
<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> inf <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x3f3f3f3f</span>;

ii tree[MAX]<span style=color:#f92672>=</span>{};
<span style=color:#66d9ef>int</span> arr[MAX];

ii <span style=color:#a6e22e>merge</span>(ii a, ii b) {

    ii c <span style=color:#f92672>=</span> {min(a.first,b.first),max(a.second,b.second),<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>};

    <span style=color:#66d9ef>if</span>(c.first<span style=color:#f92672>==</span>a.first) c.i<span style=color:#f92672>=</span>a.i;
    <span style=color:#66d9ef>else</span> c.i<span style=color:#f92672>=</span>b.i;

    <span style=color:#66d9ef>if</span>(c.second<span style=color:#f92672>==</span>a.second) c.j<span style=color:#f92672>=</span>a.j;
    <span style=color:#66d9ef>else</span> c.j<span style=color:#f92672>=</span>b.j;

    <span style=color:#66d9ef>return</span> c;
}

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>build</span>(<span style=color:#66d9ef>int</span> pos, <span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> j) {
    <span style=color:#66d9ef>if</span>(i<span style=color:#f92672>==</span>j) {
        tree[pos]<span style=color:#f92672>=</span>{arr[i],arr[i],i,i};
        <span style=color:#66d9ef>if</span>(arr[i]<span style=color:#f92672>==</span><span style=color:#ae81ff>0</span>) {
            tree[pos]<span style=color:#f92672>=</span>{inf,<span style=color:#f92672>-</span>inf,<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>};
        }
    } <span style=color:#66d9ef>else</span> {
        build(<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>pos,i,(i<span style=color:#f92672>+</span>j)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>);
        build(<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>pos<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,(i<span style=color:#f92672>+</span>j)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,j);

        tree[pos]<span style=color:#f92672>=</span>merge(tree[<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>pos],tree[<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>pos<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>]);
    }
}

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>update</span>(<span style=color:#66d9ef>int</span> pos, <span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> j, <span style=color:#66d9ef>int</span> target, ii val) {
    <span style=color:#66d9ef>if</span>(i<span style=color:#f92672>==</span>j) {
        <span style=color:#66d9ef>if</span>(tree[pos].first<span style=color:#f92672>!=</span><span style=color:#ae81ff>0</span><span style=color:#f92672>&amp;&amp;</span>tree[pos].second<span style=color:#f92672>!=</span><span style=color:#ae81ff>0</span>) {
            tree[pos]<span style=color:#f92672>=</span>merge(tree[pos],val);
        } <span style=color:#66d9ef>else</span> {
            tree[pos]<span style=color:#f92672>=</span>val; 
        }
    } <span style=color:#66d9ef>else</span> {
        <span style=color:#66d9ef>if</span>(target <span style=color:#f92672>&lt;=</span> (i<span style=color:#f92672>+</span>j)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>) update(<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>pos,i,(i<span style=color:#f92672>+</span>j)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>,target,val);
        <span style=color:#66d9ef>else</span> update(<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>pos<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,(i<span style=color:#f92672>+</span>j)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,j,target,val);

        tree[pos]<span style=color:#f92672>=</span>merge(tree[<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>pos],tree[<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>pos<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>]);
    }
}

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>force_update</span>(<span style=color:#66d9ef>int</span> pos, <span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> j, <span style=color:#66d9ef>int</span> target, ii val) {
    <span style=color:#66d9ef>if</span>(i<span style=color:#f92672>==</span>j) {
        tree[pos]<span style=color:#f92672>=</span>val; 
    } <span style=color:#66d9ef>else</span> {
        <span style=color:#66d9ef>if</span>(target <span style=color:#f92672>&lt;=</span> (i<span style=color:#f92672>+</span>j)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>) force_update(<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>pos,i,(i<span style=color:#f92672>+</span>j)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>,target,val);
        <span style=color:#66d9ef>else</span> force_update(<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>pos<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,(i<span style=color:#f92672>+</span>j)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,j,target,val);
        tree[pos]<span style=color:#f92672>=</span>merge(tree[<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>pos],tree[<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>pos<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>]);
    }
}

ii <span style=color:#a6e22e>query</span>(<span style=color:#66d9ef>int</span> pos, <span style=color:#66d9ef>int</span> i, <span style=color:#66d9ef>int</span> j, <span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b) {
    <span style=color:#66d9ef>if</span>(i<span style=color:#f92672>&gt;</span>b<span style=color:#f92672>||</span>j<span style=color:#f92672>&lt;</span>a) {
        <span style=color:#66d9ef>return</span> {inf,<span style=color:#f92672>-</span>inf, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>};
    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span>(i<span style=color:#f92672>&gt;=</span>a<span style=color:#f92672>&amp;&amp;</span>j<span style=color:#f92672>&lt;=</span>b) {
        <span style=color:#66d9ef>return</span> tree[pos];
    } <span style=color:#66d9ef>else</span> {
        <span style=color:#66d9ef>return</span> merge(query(<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>pos,i,(i<span style=color:#f92672>+</span>j)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>,a,b),query(<span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>pos<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,(i<span style=color:#f92672>+</span>j)<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>,j,a,b));
    }
}

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {

    <span style=color:#66d9ef>int</span> n,m;
    scanf(<span style=color:#e6db74>&#34;%d%d&#34;</span>,<span style=color:#f92672>&amp;</span>n,<span style=color:#f92672>&amp;</span>m);

    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span>n;i<span style=color:#f92672>++</span>) scanf(<span style=color:#e6db74>&#34;%d&#34;</span>,<span style=color:#f92672>&amp;</span>arr[i]);

    build(<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>,n);

    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>&lt;</span>m;i<span style=color:#f92672>++</span>) {
        <span style=color:#66d9ef>int</span> op;
        scanf(<span style=color:#e6db74>&#34;%d&#34;</span>,<span style=color:#f92672>&amp;</span>op);

        <span style=color:#66d9ef>if</span>(op<span style=color:#f92672>==</span><span style=color:#ae81ff>1</span>) {
            <span style=color:#66d9ef>int</span> w,p;
            scanf(<span style=color:#e6db74>&#34;%d%d&#34;</span>,<span style=color:#f92672>&amp;</span>w,<span style=color:#f92672>&amp;</span>p);
            <span style=color:#f92672>--</span>p;
            update(<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>,n,p,{w,w,p,p});
        } <span style=color:#66d9ef>else</span> {
            <span style=color:#66d9ef>int</span> a,b;
            scanf(<span style=color:#e6db74>&#34;%d%d&#34;</span>,<span style=color:#f92672>&amp;</span>a,<span style=color:#f92672>&amp;</span>b);
            <span style=color:#f92672>--</span>a,<span style=color:#f92672>--</span>b;
            ii p <span style=color:#f92672>=</span> query(<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>,n,a,b);

            <span style=color:#66d9ef>if</span>(p.i<span style=color:#f92672>==</span>p.j) {
                ii tmp <span style=color:#f92672>=</span> p;
                <span style=color:#66d9ef>int</span> ans<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
                force_update(<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>,n,p.i,{p.first,<span style=color:#f92672>-</span>inf,p.i,p.j});
                ii A <span style=color:#f92672>=</span> query(<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>,n,a,b);
                force_update(<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>,n,p.i,{inf,p.second,p.i,p.j});
                ii B <span style=color:#f92672>=</span> query(<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>,n,a,b);

                ans<span style=color:#f92672>=</span>max(A.second<span style=color:#f92672>-</span>A.first,B.second<span style=color:#f92672>-</span>B.first);
                printf(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,ans);

                update(<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>0</span>,n,p.i,p);
            } <span style=color:#66d9ef>else</span> {
                printf(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,p.second<span style=color:#f92672>-</span>p.first);
            }
        }
        
    }

    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><footer><ul class=Tags><li class="Tags-item u-background"><a class="Tags-link u-clickable" href=/categories/competitive-programming/ rel=tag>Competitive Programming</a></li></ul><ul class=Tags><li class="Tags-item u-background"><a class="Tags-link u-clickable" href=/tags/obi/ rel=tag>OBI</a></li></ul></footer></article></div></div></main></body></html>