<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Gabriel Schneider's personal blog"><meta itemprop=name content="gbrls"><meta itemprop=description content="Gabriel Schneider's personal blog"><meta property="og:title" content="gbrls"><meta property="og:description" content="Gabriel Schneider's personal blog"><meta property="og:type" content="website"><meta property="og:url" content="https://gbrls.netlify.com/"><meta property="og:updated_time" content="2019-03-26T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="gbrls"><meta name=twitter:description content="Gabriel Schneider's personal blog"><meta name=generator content="Hugo 0.66.0"><title>gbrls</title><link rel=canonical href=/><link rel=alternate type=application/rss+xml href=/index.xml title=gbrls><link rel=stylesheet href=/css/base.min.1a0a1f9140a60cc15b9f4169eb54b4ec2f5c75ea37240cc1e5a67cec0188d3ae.css integrity="sha256-GgofkUCmDMFbn0Fp61S07C9cdeo3JAzB5aZ87AGI064=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css integrity=sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js integrity=sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload=renderMathInElement(document.body);></script><link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel=stylesheet></head><body><nav class=u-background><div class=u-wrapper><ul class=Banner><li class="Banner-item Banner-item--title"><a class="Banner-link u-clickable" href=/>gbrls</a></li><li class=Banner-item><a class="Banner-link u-clickable" href=/about/>About</a></li><li class=Banner-item><a class="Banner-link u-clickable" href=/posts/>Posts</a></li><li class=Banner-item><a class="Banner-link u-clickable" href=/tags/>Tags</a></li><li class=Banner-item><a class="Banner-link u-clickable" href=/categories/>Categories</a></li><li class=Banner-item><a class="Banner-link u-clickable" href=/index.xml>RSS</a></li></ul></div></nav><main><div class=u-wrapper><div class=u-padding><article><header class=Heading><h2 class=Heading-title><a class="Heading-link u-clickable" href=/obi2018-baldes/ rel=bookmark>Solução OBI 2018 Baldes</a></h2><time datetime=2020-02-05T00:00:00Z>5 February, 2020</time></header>Enunciado
Na minha primeira leitura, vi que esta é uma questão clássica de segtree. Um vetor de tamanho \(10^5\) e \(10^5\) queries dentro desse intervalo. Iremos fazer uma segtree para o mínimo num intervalo e outra para o máximo, sendo a resposta da query em um intervalo o max-min. Para simplificar isso, podemos guardar as duas árvores apenas em um vetor de pairs.
Porém após implementar a primeira solução e não funcionar fiz uma segunda leitura e percebi que o max e o min não podem estar no mesmo balde (na mesma posição no vetor).<p><a class=u-clickable href=/obi2018-baldes/>Read More…</a></p><footer><ul class=Tags><li class="Tags-item u-background"><a class="Tags-link u-clickable" href=/categories/competitive-programming/ rel=tag>Competitive Programming</a></li></ul><ul class=Tags><li class="Tags-item u-background"><a class="Tags-link u-clickable" href=/tags/obi/ rel=tag>OBI</a></li></ul></footer></article><article><header class=Heading><h2 class=Heading-title><a class="Heading-link u-clickable" href=/obi2018-bolas/ rel=bookmark>Solução OBI 2018 Bolas</a></h2><time datetime=2020-02-05T00:00:00Z>5 February, 2020</time></header>Enunciado.
Como o tamano do vetor é \(8\) e temos sempre \(8\) números para escolher, existem \(8!\) permutações possíveis. Como \(8!\) é pequeno, podemos fazer uma solução de busca completa. Existem de varias soluções possíveis como com next_permutation. Segue uma solução de backtracking:
#include &lt;bits/stdc++.h>using namespace std; int vet[9]={}; int solve(int pos, int n) { if(pos==8) return 1; int ans=0; for(int i=0;i&lt;=9;i++) { if(n != i && vet[i]) { vet[i]--; ans|=solve(pos+1,i); vet[i]++; } } return ans; } int main() { for(int i=0;i&lt;8;i++) { int aux; scanf("%d",&aux); vet[aux]++; } int ans=solve(0,-1); puts(ans?<p><a class=u-clickable href=/obi2018-bolas/>Read More…</a></p><footer><ul class=Tags><li class="Tags-item u-background"><a class="Tags-link u-clickable" href=/categories/competitive-programming/ rel=tag>Competitive Programming</a></li></ul><ul class=Tags><li class="Tags-item u-background"><a class="Tags-link u-clickable" href=/tags/obi/ rel=tag>OBI</a></li></ul></footer></article><article><header class=Heading><h2 class=Heading-title><a class="Heading-link u-clickable" href=/obi2018-cinco/ rel=bookmark>Solução OBI 2018 Cinco</a></h2><time datetime=2020-02-05T00:00:00Z>5 February, 2020</time></header>Enunciado
Podemos criar um algoritmo guloso simples, trocar sempre (em ordem):
O dígito mais significativo que for trocado por um número maior do que ele (na falha do primeiro) O dígito menos significativo que for trocado por um número menor do que ele #include &lt;bits/stdc++.h>using namespace std; int main() { int n; scanf("%d",&n); int arr[n]; for(int i=0;i&lt;n;i++) scanf("%d",&arr[i]); for(int i=0;i&lt;n;i++) { if(arr[i]&lt;arr[n-1]&&(arr[i]==0||arr[i]==5)) { swap(arr[i],arr[n-1]); for(int j=0;j&lt;n;j++) printf("%d%c",arr[j],j==n-1?'\n':' '); exit(0); } } for(int i=n-1;i>=0;i--) { if(arr[i]==0||arr[i]==5) { swap(arr[i],arr[n-1]); for(int j=0;j&lt;n;j++) printf("%d%c",arr[j],j==n-1?<p><a class=u-clickable href=/obi2018-cinco/>Read More…</a></p><footer><ul class=Tags><li class="Tags-item u-background"><a class="Tags-link u-clickable" href=/categories/competitive-programming/ rel=tag>Competitive Programming</a></li></ul><ul class=Tags><li class="Tags-item u-background"><a class="Tags-link u-clickable" href=/tags/obi/ rel=tag>OBI</a></li></ul></footer></article><article><header class=Heading><h2 class=Heading-title><a class="Heading-link u-clickable" href=/obi2018-maximin/ rel=bookmark>Solução OBI 2018 Maximin</a></h2><time datetime=2020-02-05T00:00:00Z>5 February, 2020</time></header>Enunciado
Como o tamanho máximo do vetor é \(10^5\) podemos ordená-lo. Fazendo isso podemos ver que o número que estamos procurando está entre dois números vizinhos no vetor ou está em alguma das extremidades.
#include &lt;bits/stdc++.h>using namespace std; int main() { int n,r,l; scanf("%d%d%d",&n,&r,&l); int arr[n]; for(int i=0;i&lt;n;i++) scanf("%d",&arr[i]); sort(arr,arr+n); int dif=0; for(int i=1;i&lt;n;i++) { int mid=(arr[i]+arr[i-1])/2; if(mid>=r&&mid&lt;=l) dif=max(dif,min(abs(mid-arr[i]),abs(mid-arr[i-1]))); } if(l>arr[n-1]) dif=max(dif, l-arr[n-1]); if(r&lt;arr[0]) dif=max(dif,arr[0]-r); printf("%d\n",dif); return 0; }<footer><ul class=Tags><li class="Tags-item u-background"><a class="Tags-link u-clickable" href=/categories/competitive-programming/ rel=tag>Competitive Programming</a></li></ul><ul class=Tags><li class="Tags-item u-background"><a class="Tags-link u-clickable" href=/tags/obi/ rel=tag>OBI</a></li></ul></footer></article><article><header class=Heading><h2 class=Heading-title><a class="Heading-link u-clickable" href=/obi2018-muro/ rel=bookmark>Solução OBI 2018 Muro</a></h2><time datetime=2020-02-05T00:00:00Z>5 February, 2020</time></header>Enunciado
Podemos criar uma função recursiva: \(f(n) = f(n-1) + 4f(n-2) + 2f(n-3)\). Como existem estados que irão se repetir, podemos usar um vetor para guardar o valor da função já computados.
#include &lt;bits/stdc++.h>#define int long long int using namespace std; const int mod = 1e9+7; const int MAX = 1e4+20; int dp[MAX]={}; int solve(int pos) { if(pos==0) return 1; if(~dp[pos]) return dp[pos]; int ans=0; ans = (ans+solve(pos-1))%mod; if(pos>=2) ans = (ans+4*solve(pos-2))%mod; if(pos>=3) ans = (ans+2*solve(pos-3))%mod; return dp[pos]=ans; } int32_t main() { memset(dp,-1,sizeof(dp)); int n; scanf("%lld",&n); printf("%lld\n",solve(n)); return 0; }<footer><ul class=Tags><li class="Tags-item u-background"><a class="Tags-link u-clickable" href=/categories/competitive-programming/ rel=tag>Competitive Programming</a></li></ul><ul class=Tags><li class="Tags-item u-background"><a class="Tags-link u-clickable" href=/tags/obi/ rel=tag>OBI</a></li></ul></footer></article></div></div></main></body></html>