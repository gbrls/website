<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Enunciado
Podemos criar uma função recursiva: \(f(n) = f(n-1) + 4f(n-2) + 2f(n-3)\). Como existem estados que irão se repetir, podemos usar um vetor para guardar o valor da função já computados.
#include <bits/stdc++.h>#define int long long int using namespace std; const int mod = 1e9+7; const int MAX = 1e4+20; int dp[MAX]={}; int solve(int pos) { if(pos==0) return 1; if(~dp[pos]) return dp[pos]; int ans=0; ans = (ans+solve(pos-1))%mod; if(pos>=2) ans = (ans+4*solve(pos-2))%mod; if(pos>=3) ans = (ans+2*solve(pos-3))%mod; return dp[pos]=ans; } int32_t main() { memset(dp,-1,sizeof(dp)); int n; scanf(&#34;%lld&#34;,&n); printf(&#34;%lld\n&#34;,solve(n)); return 0; }"><meta itemprop=name content="Solução OBI 2018 Muro"><meta itemprop=description content="Enunciado
Podemos criar uma função recursiva: \(f(n) = f(n-1) + 4f(n-2) + 2f(n-3)\). Como existem estados que irão se repetir, podemos usar um vetor para guardar o valor da função já computados.
#include <bits/stdc++.h>#define int long long int using namespace std; const int mod = 1e9+7; const int MAX = 1e4+20; int dp[MAX]={}; int solve(int pos) { if(pos==0) return 1; if(~dp[pos]) return dp[pos]; int ans=0; ans = (ans+solve(pos-1))%mod; if(pos>=2) ans = (ans+4*solve(pos-2))%mod; if(pos>=3) ans = (ans+2*solve(pos-3))%mod; return dp[pos]=ans; } int32_t main() { memset(dp,-1,sizeof(dp)); int n; scanf(&#34;%lld&#34;,&n); printf(&#34;%lld\n&#34;,solve(n)); return 0; }"><meta itemprop=datePublished content="2020-02-05T00:00:00+00:00"><meta itemprop=dateModified content="2020-02-05T00:00:00+00:00"><meta itemprop=wordCount content="90"><meta itemprop=keywords content="OBI,"><meta property="og:title" content="Solução OBI 2018 Muro"><meta property="og:description" content="Enunciado
Podemos criar uma função recursiva: \(f(n) = f(n-1) + 4f(n-2) + 2f(n-3)\). Como existem estados que irão se repetir, podemos usar um vetor para guardar o valor da função já computados.
#include <bits/stdc++.h>#define int long long int using namespace std; const int mod = 1e9+7; const int MAX = 1e4+20; int dp[MAX]={}; int solve(int pos) { if(pos==0) return 1; if(~dp[pos]) return dp[pos]; int ans=0; ans = (ans+solve(pos-1))%mod; if(pos>=2) ans = (ans+4*solve(pos-2))%mod; if(pos>=3) ans = (ans+2*solve(pos-3))%mod; return dp[pos]=ans; } int32_t main() { memset(dp,-1,sizeof(dp)); int n; scanf(&#34;%lld&#34;,&n); printf(&#34;%lld\n&#34;,solve(n)); return 0; }"><meta property="og:type" content="article"><meta property="og:url" content="https://gbrls.netlify.com/obi2018-muro/"><meta property="article:published_time" content="2020-02-05T00:00:00+00:00"><meta property="article:modified_time" content="2020-02-05T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Solução OBI 2018 Muro"><meta name=twitter:description content="Enunciado
Podemos criar uma função recursiva: \(f(n) = f(n-1) + 4f(n-2) + 2f(n-3)\). Como existem estados que irão se repetir, podemos usar um vetor para guardar o valor da função já computados.
#include <bits/stdc++.h>#define int long long int using namespace std; const int mod = 1e9+7; const int MAX = 1e4+20; int dp[MAX]={}; int solve(int pos) { if(pos==0) return 1; if(~dp[pos]) return dp[pos]; int ans=0; ans = (ans+solve(pos-1))%mod; if(pos>=2) ans = (ans+4*solve(pos-2))%mod; if(pos>=3) ans = (ans+2*solve(pos-3))%mod; return dp[pos]=ans; } int32_t main() { memset(dp,-1,sizeof(dp)); int n; scanf(&#34;%lld&#34;,&n); printf(&#34;%lld\n&#34;,solve(n)); return 0; }"><meta name=generator content="Hugo 0.66.0"><title>Solução OBI 2018 Muro | gbrls</title><link rel=canonical href=/obi2018-muro/><link rel=stylesheet href=/css/base.min.1a0a1f9140a60cc15b9f4169eb54b4ec2f5c75ea37240cc1e5a67cec0188d3ae.css integrity="sha256-GgofkUCmDMFbn0Fp61S07C9cdeo3JAzB5aZ87AGI064=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css integrity=sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js integrity=sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload=renderMathInElement(document.body);></script><link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel=stylesheet></head><body><nav class=u-background><div class=u-wrapper><ul class=Banner><li class="Banner-item Banner-item--title"><a class="Banner-link u-clickable" href=/>gbrls</a></li><li class=Banner-item><a class="Banner-link u-clickable" href=/about/>About</a></li><li class=Banner-item><a class="Banner-link u-clickable" href=/posts/>Posts</a></li><li class=Banner-item><a class="Banner-link u-clickable" href=/tags/>Tags</a></li><li class=Banner-item><a class="Banner-link u-clickable" href=/categories/>Categories</a></li><li class=Banner-item><a class="Banner-link u-clickable" href=/index.xml>RSS</a></li></ul></div></nav><main><div class=u-wrapper><div class=u-padding><article><header class=Heading><h2 class=Heading-title><a class="Heading-link u-clickable" href=/obi2018-muro/ rel=bookmark>Solução OBI 2018 Muro</a></h2><time datetime=2020-02-05T00:00:00Z>5 February, 2020</time></header><p><a href=https://olimpiada.ic.unicamp.br/pratique/pu/2018/f3/muro/>Enunciado</a><br>Podemos criar uma função recursiva: <span class=math>\(f(n) = f(n-1) + 4f(n-2) + 2f(n-3)\)</span>. Como existem estados que irão se repetir, podemos
usar um vetor para guardar o valor da função já computados.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;bits/stdc++.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#define int long long int
</span><span style=color:#75715e></span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;

<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> mod <span style=color:#f92672>=</span> <span style=color:#ae81ff>1e9</span><span style=color:#f92672>+</span><span style=color:#ae81ff>7</span>;
<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> MAX <span style=color:#f92672>=</span> <span style=color:#ae81ff>1e4</span><span style=color:#f92672>+</span><span style=color:#ae81ff>20</span>;

<span style=color:#66d9ef>int</span> dp[MAX]<span style=color:#f92672>=</span>{};

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>solve</span>(<span style=color:#66d9ef>int</span> pos) {
    <span style=color:#66d9ef>if</span>(pos<span style=color:#f92672>==</span><span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
    <span style=color:#66d9ef>if</span>(<span style=color:#f92672>~</span>dp[pos]) <span style=color:#66d9ef>return</span> dp[pos];

    <span style=color:#66d9ef>int</span> ans<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;

    ans <span style=color:#f92672>=</span> (ans<span style=color:#f92672>+</span>solve(pos<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>))<span style=color:#f92672>%</span>mod;
    <span style=color:#66d9ef>if</span>(pos<span style=color:#f92672>&gt;=</span><span style=color:#ae81ff>2</span>) ans <span style=color:#f92672>=</span> (ans<span style=color:#f92672>+</span><span style=color:#ae81ff>4</span><span style=color:#f92672>*</span>solve(pos<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>))<span style=color:#f92672>%</span>mod;
    <span style=color:#66d9ef>if</span>(pos<span style=color:#f92672>&gt;=</span><span style=color:#ae81ff>3</span>) ans <span style=color:#f92672>=</span> (ans<span style=color:#f92672>+</span><span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>solve(pos<span style=color:#f92672>-</span><span style=color:#ae81ff>3</span>))<span style=color:#f92672>%</span>mod;

    <span style=color:#66d9ef>return</span> dp[pos]<span style=color:#f92672>=</span>ans;
}

<span style=color:#66d9ef>int32_t</span> <span style=color:#a6e22e>main</span>() {

    memset(dp,<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,<span style=color:#66d9ef>sizeof</span>(dp));
    <span style=color:#66d9ef>int</span> n;
    scanf(<span style=color:#e6db74>&#34;%lld&#34;</span>,<span style=color:#f92672>&amp;</span>n);

    printf(<span style=color:#e6db74>&#34;%lld</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,solve(n));

    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><footer><ul class=Tags><li class="Tags-item u-background"><a class="Tags-link u-clickable" href=/categories/competitive-programming/ rel=tag>Competitive Programming</a></li></ul><ul class=Tags><li class="Tags-item u-background"><a class="Tags-link u-clickable" href=/tags/obi/ rel=tag>OBI</a></li></ul></footer></article></div></div></main></body></html>